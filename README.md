# 布尔逻辑表达式化简器 (离散数学课程设计)

## 1. 项目背景：一个算法挑战

这是我在“离散数学”课程中完成的一个极具挑战性的加分大作业。

**题目要求：** 给定一个包含3、5或10个变量的真值表，要求编写程序，找出一个与之等价的、并且尽可能简洁的逻辑表达式（合式公式）。

这本质上是一个经典的**逻辑表达式化简 (Logic Minimization)** 问题，是数字电路设计和逻辑综合领域的基础。面对这个开放性的问题，我决定从第一性原理出发，用自己的思考和代码，独立地设计并实现一套解决方案。这个仓库完整地记录了我从暴力尝试到最终实现高效启发式算法的全过程。

---

## 2. 我的探索历程：从暴力到启发式

我的整个解题过程，是一次典型的算法设计与迭代的旅程。

#### **第一阶段：暴力搜索法 (`1_Bruteforce_Method/`)**

我的第一个想法是“暴力枚举”。通过`itertools`生成所有可能的表达式，再用`eval()`逐一验证。这个方法虽然直接，但很快就暴露了**组合爆炸**的致命缺陷——在处理5个变量时，其计算量已经超出了实际可接受的范围。这次失败的尝试，让我深刻认识到，对于这类NP问题，必须寻找更智能的启发式算法。

#### **第二阶段 (核心)：基于Q-M思想的启发式化简 (`2_Quine_McCluskey_Method/`)**

在意识到暴力法的局限性后，我回归到离散数学的本质，**独立设计并实现了一套受Q-M (Quine-McCluskey) 算法思想启发的启发式算法**。

*   **核心思想:** 不再盲目地构造公式，而是直接从真值表的数据规律入手，通过“合并同类项”来逐步化简。

*   **我的实现步骤:**
    1.  **提取最小项 (Minterms):** 首先，从真值表中筛选出所有结果为`1`的行。这是构成表达式“主析取范式”的全部基础。
    2.  **寻找并合并“相邻”项:** 我编写了核心的比较函数 (`is_same`)，来寻找那些仅有一个变量不同的最小项对（例如 `a∧b∧c` 和 `a∧b∧¬c`）。这些“相邻”的项可以被合并，消去那个不同的变量（合并为 `a∧b`）。
    3.  **迭代化简:** 我将这个合并过程**迭代**进行。上一轮合并产生的新项，会继续作为输入参与下一轮的合并（例如 `a∧b` 和 `a∧¬b` 可以进一步合并为 `a`）。这个过程会一直持续，直到无法再进行任何合并为止，最终得到一组“**主蕴含项 (Prime Implicants)**”。
    4.  **构建最终表达式:** 最后，我将这些化简后的主蕴含项用`∨`（或）连接起来，就得到了一个高度化简的析取范式表达式。

---

## 3. 技术汇总

*   **核心算法:** 本项目的核心亮点在于，没有调用任何外部库来完成逻辑化简，而是从零开始**实现了完整的、基于Q-M思想的启发式化简流程**。
*   **计算思维的跃迁:** 完整地展现了从“暴力解”到“高效启发式解”的算法优化思路转变。
*   **数据处理:** 熟练使用Python进行数据处理、列表操作和复杂的逻辑控制。

---

## 4. 文件结构与使用

*   `1_Bruteforce_Method/`: 早期暴力搜索算法的实现。
*   `2_Quine_McCluskey_Method/`: **核心的启发式化简算法**。
*   `data/`: 作业所使用的输入数据（CSV格式）。
*   `utils/`: 一些辅助脚本。
*   `requirements.txt`: 项目的Python依赖。

#### **如何运行 (启发式算法示例)**
```bash
# 安装依赖
pip install -r requirements.txt

# 运行主程序 (请根据你的主文件名修改)
python 2_Quine_McCluskey_Method/your_main_solver.py
```
程序会读取`data/`目录下的真值表（需要重新设置路径），并输出化简后的逻辑表达式。

---

## 5. 总结

这个项目是我迄今为止遇到的最具挑战性、也最有趣的项目之一。它让我深刻地认识到，对于复杂问题，一个好的算法设计远比单纯的计算性能要重要得多。从暴力枚举的失败到启发式算法的成功，这个过程极大地锻炼了我的抽象思维和问题分解能力，也让我第一次体会到了将理论知识转化为解决实际问题的代码的乐趣。